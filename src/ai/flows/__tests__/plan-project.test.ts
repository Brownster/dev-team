import { PlanProjectInput, PlanProjectOutput } from '../plan-project';
// Do not import `ai` or `researchTask` at the top level.

const mockPromptFn = jest.fn();
const mockResearchTaskFn = jest.fn();
let capturedFlowLogic: ((input: PlanProjectInput) => Promise<PlanProjectOutput>) | undefined;

describe('planProject Flow', () => {
  beforeEach(() => {
    jest.resetModules();
    mockPromptFn.mockReset();
    mockResearchTaskFn.mockReset();
    capturedFlowLogic = undefined;
  });

  async function getMockedFlow() {
    let aiInstanceForAssertions: any;
    let researchTaskForAssertions: any;

    // Mock researchTask first as it's a specific dependency
    jest.doMock('@/ai/flows/research-task', () => {
      researchTaskForAssertions = mockResearchTaskFn;
      return { researchTask: mockResearchTaskFn };
    });

    jest.doMock('@/ai/ai-instance', () => {
      const mockAi = {
        definePrompt: jest.fn().mockImplementation(() => mockPromptFn),
        defineFlow: jest.fn().mockImplementation((config: any, implementation: any) => {
          capturedFlowLogic = implementation;
          return jest.fn(async (input: PlanProjectInput) => {
            if (!capturedFlowLogic) {
              throw new Error('Flow implementation logic not captured correctly.');
            }
            return capturedFlowLogic(input);
          });
        }),
      };
      aiInstanceForAssertions = mockAi;
      return { ai: mockAi };
    });

    const { planProject } = await import('../plan-project');
    return { planProject, mockedAi: aiInstanceForAssertions, mockedResearchTask: researchTaskForAssertions };
  }

  it('should plan a project successfully with valid input', async () => {
    const { planProject } = await getMockedFlow();
    const input: PlanProjectInput = { projectIdea: 'Build a new to-do app.' };
    const researchResult = { info: 'Research shows users prefer simple UIs for to-do apps.' };
    const expectedTasks = [
      { description: 'Design simple UI (based on research: Research shows users prefer simple UIs for to-do apps.)', assignee: 'Developer' as const },
      { description: 'Implement core to-do functionality', assignee: 'Developer' as const },
    ];
    const promptOutput = { tasks: expectedTasks };

    mockResearchTaskFn.mockResolvedValue(researchResult);
    mockPromptFn.mockResolvedValue({ output: promptOutput });

    expect(typeof planProject).toBe('function');
    const result = await planProject(input);

    expect(result.tasks).toEqual(expectedTasks);
    expect(mockResearchTaskFn).toHaveBeenCalledWith({ query: `development information related to ${input.projectIdea}` });
    expect(mockPromptFn).toHaveBeenCalledWith({
      projectIdea: input.projectIdea,
      researchInfo: researchResult.info,
    });
  });

  it('should throw an error if researchTask fails', async () => {
    const { planProject } = await getMockedFlow();
    const input: PlanProjectInput = { projectIdea: 'A project that will cause research to fail.' };
    const researchError = new Error('Research API unavailable');
    mockResearchTaskFn.mockRejectedValue(researchError);

    expect(typeof planProject).toBe('function');
    await expect(planProject(input)).rejects.toThrow(`Failed to plan project: ${researchError.message}`);
    expect(mockResearchTaskFn).toHaveBeenCalledWith({ query: `development information related to ${input.projectIdea}` });
    expect(mockPromptFn).not.toHaveBeenCalled();
  });

  it('should throw an error if the planning prompt fails', async () => {
    const { planProject } = await getMockedFlow();
    const input: PlanProjectInput = { projectIdea: 'A project where planning prompt fails.' };
    const researchResult = { info: 'Some research data.' };
    const promptError = new Error('Prompt generation error');

    mockResearchTaskFn.mockResolvedValue(researchResult);
    mockPromptFn.mockRejectedValue(promptError);

    expect(typeof planProject).toBe('function');
    await expect(planProject(input)).rejects.toThrow(`Failed to plan project: ${promptError.message}`);
    expect(mockPromptFn).toHaveBeenCalledWith({
      projectIdea: input.projectIdea,
      researchInfo: researchResult.info,
    });
  });

  it('should throw an error if the planning prompt returns no output', async () => {
    const { planProject } = await getMockedFlow();
    const input: PlanProjectInput = { projectIdea: 'A project with no prompt output.' };
    const researchResult = { info: 'Some research data.' };

    mockResearchTaskFn.mockResolvedValue(researchResult);
    mockPromptFn.mockResolvedValue({ output: undefined });

    expect(typeof planProject).toBe('function');
    await expect(planProject(input)).rejects.toThrow('Failed to plan project: No output generated by the AI prompt for project planning.');
  });

  it('should ensure ai.definePrompt, ai.defineFlow, and researchTask are set up for mocking', async () => {
    const { mockedAi, mockedResearchTask } = await getMockedFlow();
    expect(mockedAi.definePrompt).toHaveBeenCalled();
    expect(mockedAi.defineFlow).toHaveBeenCalled();
    // researchTask is mocked at the module level, so we check our mockResearchTaskFn
    // This test primarily ensures getMockedFlow() sets up the mocks correctly.
    // If planProject was called, mockedResearchTask would be toHaveBeenCalled.
    expect(mockResearchTaskFn).not.toHaveBeenCalled(); // It shouldn't be called just by importing
  });
});
