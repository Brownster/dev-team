import { GenerateCodeInput, GenerateCodeOutput } from '../generate-code';
// We do not import `ai` from `@/ai/ai-instance` here at the top level.

// This will be the mock for the prompt function itself.
const mockPromptFn = jest.fn();
// This variable will store the actual function logic passed to ai.defineFlow
// by the generate-code.ts module when it's imported under a mocked context.
let capturedFlowLogic: ((input: GenerateCodeInput) => Promise<GenerateCodeOutput>) | undefined;

describe('generateCode Flow', () => {
  beforeEach(() => {
    // Reset modules before each test to ensure a fresh state for imports and mocks.
    jest.resetModules();
    mockPromptFn.mockReset();
    capturedFlowLogic = undefined; // Reset captured logic
  });

  // Helper function to set up mocks and import the module.
  // This ensures that `jest.doMock` is called before `import()`.
  async function getMockedFlow() {
    let aiInstanceForAssertions: any; // To store the mocked ai object for assertions

    jest.doMock('@/ai/ai-instance', () => {
      const mockAi = {
        definePrompt: jest.fn().mockImplementation(() => mockPromptFn),
        defineFlow: jest.fn().mockImplementation((config: any, implementation: any) => {
          capturedFlowLogic = implementation;
          // This is the function that will be returned as the flow (e.g., generateCode)
          return jest.fn(async (input: GenerateCodeInput) => {
            if (!capturedFlowLogic) {
              throw new Error('Flow implementation logic not captured correctly.');
            }
            return capturedFlowLogic(input);
          });
        }),
      };
      aiInstanceForAssertions = mockAi; // Store for later assertions
      return { ai: mockAi };
    });

    // Dynamically import the module AFTER mocks are set up.
    const { generateCode } = await import('../generate-code');
    return { generateCode, mockedAi: aiInstanceForAssertions };
  }

  it('should generate code successfully with valid input', async () => {
    const { generateCode } = await getMockedFlow();
    const input: GenerateCodeInput = { taskDescription: 'Create a simple React component.' };
    const expectedOutputFromPrompt: GenerateCodeOutput = {
      code: 'const MyComponent = () => <div>Hello World</div>;',
      progress: 'Generated Next.js code based on the provided task description.',
    };

    mockPromptFn.mockResolvedValue({ output: expectedOutputFromPrompt });

    expect(typeof generateCode).toBe('function');
    const result = await generateCode(input);

    expect(result.code).toBe(expectedOutputFromPrompt.code);
    expect(result.progress).toBe(expectedOutputFromPrompt.progress);
    expect(mockPromptFn).toHaveBeenCalledWith(input);
  });

  it('should throw an error if the prompt returns no output', async () => {
    const { generateCode } = await getMockedFlow();
    const input: GenerateCodeInput = { taskDescription: 'This will fail.' };
    mockPromptFn.mockResolvedValue({ output: undefined });

    expect(typeof generateCode).toBe('function');
    await expect(generateCode(input)).rejects.toThrow('Failed to generate code: No output generated by the AI prompt.');
    expect(mockPromptFn).toHaveBeenCalledWith(input);
  });

  it('should throw an error if the prompt itself throws an error', async () => {
    const { generateCode } = await getMockedFlow();
    const input: GenerateCodeInput = { taskDescription: 'Prompt throws error.' };
    const promptError = new Error('Prompt internal error');
    mockPromptFn.mockRejectedValue(promptError);

    expect(typeof generateCode).toBe('function');
    await expect(generateCode(input)).rejects.toThrow(`Failed to generate code: ${promptError.message}`);
    expect(mockPromptFn).toHaveBeenCalledWith(input);
  });

  it('should ensure ai.definePrompt and ai.defineFlow were called on module load', async () => {
    const { mockedAi } = await getMockedFlow(); // This imports the module
    // Assert that the definePrompt and defineFlow on our mockAi were called
    expect(mockedAi.definePrompt).toHaveBeenCalled();
    expect(mockedAi.defineFlow).toHaveBeenCalled();
  });
});
