import { ResearchTaskInput, ResearchTaskOutput } from '../research-task';
// Do not import `ai` from `@/ai/ai-instance` here at the top level.

const mockPromptFn = jest.fn();
let capturedFlowLogic: ((input: ResearchTaskInput) => Promise<ResearchTaskOutput>) | undefined;

describe('researchTask Flow', () => {
  beforeEach(() => {
    jest.resetModules();
    mockPromptFn.mockReset();
    capturedFlowLogic = undefined;
  });

  async function getMockedFlow() {
    let aiInstanceForAssertions: any;

    jest.doMock('@/ai/ai-instance', () => {
      const mockAi = {
        definePrompt: jest.fn().mockImplementation(() => mockPromptFn),
        defineFlow: jest.fn().mockImplementation((config: any, implementation: any) => {
          capturedFlowLogic = implementation;
          return jest.fn(async (input: ResearchTaskInput) => {
            if (!capturedFlowLogic) {
              throw new Error('Flow implementation logic not captured correctly.');
            }
            return capturedFlowLogic(input);
          });
        }),
      };
      aiInstanceForAssertions = mockAi;
      return { ai: mockAi };
    });

    const { researchTask } = await import('../research-task');
    return { researchTask, mockedAi: aiInstanceForAssertions };
  }

  it('should perform research successfully with valid input', async () => {
    const { researchTask } = await getMockedFlow();
    const input: ResearchTaskInput = { query: 'What is Genkit?' };
    const expectedOutput: ResearchTaskOutput = {
      info: 'Genkit is an open source framework to build AI-powered applications.',
    };

    mockPromptFn.mockResolvedValue({ output: expectedOutput });

    expect(typeof researchTask).toBe('function');
    const result = await researchTask(input);

    expect(result).toEqual(expectedOutput);
    expect(mockPromptFn).toHaveBeenCalledWith(input);
  });

  it('should throw an error if the prompt returns no output', async () => {
    const { researchTask } = await getMockedFlow();
    const input: ResearchTaskInput = { query: 'A query that results in no output.' };
    mockPromptFn.mockResolvedValue({ output: undefined });

    expect(typeof researchTask).toBe('function');
    await expect(researchTask(input)).rejects.toThrow('Failed to complete research task: No output generated by the AI prompt for research task.');
    expect(mockPromptFn).toHaveBeenCalledWith(input);
  });

  it('should throw an error if the prompt itself throws an error', async () => {
    const { researchTask } = await getMockedFlow();
    const input: ResearchTaskInput = { query: 'A query that causes a prompt error.' };
    const promptError = new Error('Network error during research');
    mockPromptFn.mockRejectedValue(promptError);

    expect(typeof researchTask).toBe('function');
    await expect(researchTask(input)).rejects.toThrow(`Failed to complete research task: ${promptError.message}`);
    expect(mockPromptFn).toHaveBeenCalledWith(input);
  });

  it('should ensure ai.definePrompt and ai.defineFlow were called on module load', async () => {
    const { mockedAi } = await getMockedFlow();
    expect(mockedAi.definePrompt).toHaveBeenCalled();
    expect(mockedAi.defineFlow).toHaveBeenCalled();
  });
});
